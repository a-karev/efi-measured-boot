#! /bin/bash

cmd=$0

exec 3>&1 >&2

tkrel=
while getopts 'k:' opt; do
    case "$opt" in
        k) tkrel=$OPTARG ;;
        :) echo "$OPTARG requires an argument" >&2; return 1;;
        ?) echo "unknown argument" >&2; return 1;;
    esac
done
shift $((OPTIND-1))

[ -r /etc/efi-measured-boot/config ] && . /etc/efi-measured-boot/config
if [[ $cmd = ./* ]]; then APPDIR=.; fi
. "${APPDIR:-.}"/functions
. "${APPDIR:-.}"/bash_functions

set -e

tmpdir=$(setup_tmp_dir)

cleanup() {
    [ -n "$tmpdir" ] && rm -rf "$tmpdir"
}

trap cleanup EXIT

rootdev=( $(get_device_info /) )
cryptdev=( $(get_crypttab_entry "${rootdev[1]}") )

cryptopts=${cryptdev[3]}
if [[ $cryptopts != *luks* ]]; then
    echo "crypttab entry missing luks option: $cryptopts"
    exit 1
fi
if [[ $cryptopts != *keyscript=*emboot_unseal.sh* ]]; then
    echo "keyscript option in crypttab entry missing or invalid: $cryptopts"
    exit 1
fi

echo "root=UUID=${rootdev[0]} cryptdevice=${cryptdev[1]}:${cryptdev[0]} $KERNEL_PARAMS" >"$tmpdir"/kernel-command-line.txt

kernels=( $(list_installed_kernels) )

statefile=$(emboot_state_file)
rm -f "$statefile"
cat >$statefile <<EOF;
primary=$(quote_args "$(kernel_path_to_release "${kernels[0]}")")
old=$(quote_args "$(kernel_path_to_release "${kernels[1]}")")
EOF

update_loader() {
    whichl=$1
    kpath=$2
    lname=$3

    krel=$(kernel_path_to_release "$kpath")
    if [ -z "$tkrel" -o "$tkrel" = "$krel" ]; then
        echo "Creating $whichl EFI loader ($krel)"
        create_efi_app "$kpath" /boot/initrd.img-"$krel" "$tmpdir"/kernel-command-line.txt "$tmpdir"/linux.efi
        cp -f "$tmpdir"/linux.efi $(emboot_loader_unix_path "$lname")
    fi
}

if [ -n "${kernels[0]}" ]; then
    update_loader primary "${kernels[0]}" emboot.efi
fi

if [ -n "${kernels[1]}" ]; then
    update_loader old "${kernels[1]}" emboot_old.efi
fi

exit 0
